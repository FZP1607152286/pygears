
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>My First Instruction &#8212; PyGears - HW Design: A Functional Approach</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="canonical" href="https://www.pygears.org/riscv/my_first_instruction.html" />
    <link rel="shortcut icon" href="../_static/pygears.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="RISC-V Tools Setup" href="setup.html" />
    <link rel="prev" title="RISC-V Blog Series Introduction" href="introduction.html" />
  
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  
  <link rel="alternate" type="application/atom+xml"  href="../blog/atom.xml" title="PyGears">
  
  
  <style type="text/css">
    ul.ablog-archive {list-style: none; overflow: auto; margin-left: 0px}
    ul.ablog-archive li {float: left; margin-right: 5px; font-size: 80%}
    ul.postlist a {font-style: italic;}
    ul.postlist-style-disc {list-style-type: disc;}
    ul.postlist-style-none {list-style-type: none;}
    ul.postlist-style-circle {list-style-type: circle;}
  </style>

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="my-first-instruction">
<h1>My First Instruction<a class="headerlink" href="#my-first-instruction" title="Permalink to this headline">¶</a></h1>

<script>
 function changeVerbosity(verbosity) {

     document.getElementById("verbosity_value").value = verbosity;
     document.getElementById("verbosity_slider").value = verbosity;

     var a = document.querySelectorAll('[data-verbosity]');

     for (var i in a) if (a.hasOwnProperty(i)) {
         if (a[i].getAttribute('data-verbosity') <= verbosity) {
             a[i].removeAttribute("hidden")
         } else {
             a[i].setAttribute("hidden", "true")
         }
     }
 }
</script>

<form class="slidecontainer">
    <b>Slide to adjust verbosity level&ensp;</b>
    <input type="range" min="1" max="2" value="1" name="verbositySlider" id="verbosity_slider" onchange="changeVerbosity(this.value);">
    &ensp;
    <input type="number" maxlength="1" id="verbosity_value" min="1" max="2" value="1" oninput="changeVerbosity(this.value);" style="font-weight: bold"/>
</form>
<p><span data-verbosity="2" hidden="true"> First instruction is probably going to be unlike any other in the amount of work that I’ll need to put into implementing it, so it deserves a post on its own. </span><span> Let’s start from the RV32I description in the (currently) latest version of the </span><a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">RISC-V ISA Specification</a><span>, which is given in the </span><a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf#page=21">Chapter 2: RV32I Base Integer Instruction Set</a><span>. The specification first goes on to describe </span><a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf#page=25">Integer Computational Instructions (Chapter 2.4)</a><span>, of which the </span><code class="docutils literal notranslate"><span class="pre">addi</span></code><span> instruction is explained first, so let’s start with that one.</span></p>
<p>All RV32I instructions are encoded with 32 bits using several formats (although there is also a <a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf#page=81">Compressed Instruction Formats (Chapter 12.2)</a> but I’ll leave that for later). All the information needed for the instruction execution have to be encoded in 32 bits and formats specify where exactly is each peace of information located within these 32 bits. Usually the instruction needs to specify which operation to perform, which registers are involved (<code class="docutils literal notranslate"><span class="pre">rs</span></code> - register source or <code class="docutils literal notranslate"><span class="pre">rd</span></code> - register destination), and usually provides some immediate values as arguments (<code class="docutils literal notranslate"><span class="pre">imm</span></code> fields). One of the key advantages of the RISC-V ISA is that pieces of information of the same type (like <code class="docutils literal notranslate"><span class="pre">rd</span></code> field) are usually located at the same position within the 32 bit encoding for different formats, which proved to simplify the hardware implementation.</p>
<p>For RV32I, a set of 32 registers is needed, named <code class="docutils literal notranslate"><span class="pre">x0</span></code> - <code class="docutils literal notranslate"><span class="pre">x31</span></code>, where <code class="docutils literal notranslate"><span class="pre">x0</span></code> is different from the others in that it has a fixed value of 0, i.e it’s value cannot be changed. The ISA specification defines the <code class="docutils literal notranslate"><span class="pre">XLEN</span></code> parameter to represent the width of the registers in number of bits: either 32 or 64. I’ll try to keep <code class="docutils literal notranslate"><span class="pre">XLEN</span></code> a design parameter of the processor implementation, but I’ll first focus on a version with <code class="docutils literal notranslate"><span class="pre">XLEN=32</span></code>, i.e with the processor version with 32 bit wide registers.</p>
<div class="section" id="instruction-format">
<h2>Instruction format<a class="headerlink" href="#instruction-format" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">addi</span></code> instruction has an “Integer Register-Immediate” format, aka the “I-type” format shown on the image below. The instruction is executed by adding the value of the 12 bit immediate field <code class="docutils literal notranslate"><span class="pre">imm</span></code> to the value read from the register specified by the <code class="docutils literal notranslate"><span class="pre">rs1</span></code> field. The result is then truncated to <code class="docutils literal notranslate"><span class="pre">XLEN</span></code> bits and stored into the register specified by the <code class="docutils literal notranslate"><span class="pre">rd</span></code> field.</p>
<div class="figure align-center" id="id1">
<img alt="../_images/integer-register-immediate-instruction.png" src="../_images/integer-register-immediate-instruction.png" />
<p class="caption"><span class="caption-text">“Integer Register-Immediate” instruction format, aka the “I-type” format, from the <a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">RISC-V ISA Specification</a></span></p>
</div>
<p>Since the instruction encodings have fields that serve different purposes from one another, I’ll represent the instruction with the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/tuple.html" title="(in PyGears v0.1.1)"><code class="docutils literal notranslate"><span class="pre">Tuple</span></code></a> PyGears type. The <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/tuple.html" title="(in PyGears v0.1.1)"><code class="docutils literal notranslate"><span class="pre">Tuple</span></code></a> type represents a generic heterogenous container type akin to records and structs in other HDLs, and I can specify the names and types of the fields by providing in square brackets a Python dict where field names are mapped to the field types. For the “I-type” instructions, I ended-up with a following definition in PyGears:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TInstructionI</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[{</span>
    <span class="s1">&#39;opcode&#39;</span><span class="p">:</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
    <span class="s1">&#39;rd&#39;</span>    <span class="p">:</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
    <span class="s1">&#39;funct3&#39;</span><span class="p">:</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
    <span class="s1">&#39;rs1&#39;</span>   <span class="p">:</span> <span class="n">Uint</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
    <span class="s1">&#39;imm&#39;</span>   <span class="p">:</span> <span class="n">Int</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span>
<span class="p">}]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">opcode</span></code> and <code class="docutils literal notranslate"><span class="pre">funct3</span></code> fields determine the function to be executed, and <code class="docutils literal notranslate"><span class="pre">rd</span></code>, <code class="docutils literal notranslate"><span class="pre">rs1</span></code> and <code class="docutils literal notranslate"><span class="pre">imm</span></code> fields carry the function arguments. The <code class="docutils literal notranslate"><span class="pre">opcode</span></code> and <code class="docutils literal notranslate"><span class="pre">funct3</span></code> fields store the ID of the function, so I can represent them with an unsigned number, i.e the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/uint.html" title="(in PyGears v0.1.1)"><code class="docutils literal notranslate"><span class="pre">Uint</span></code></a> PyGears type. Some enumerated type might constrain this fields better, since not all function IDs might be available in a specific processor implementation (after this blog post I will have implemented only one function - <code class="docutils literal notranslate"><span class="pre">addi</span></code>). However, PyGears doesn’t yet have enumerated types, so I’ll use the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/uint.html" title="(in PyGears v0.1.1)"><code class="docutils literal notranslate"><span class="pre">Uint</span></code></a> type as the second best.</p>
<p>Values of the <code class="docutils literal notranslate"><span class="pre">rs1</span></code> and <code class="docutils literal notranslate"><span class="pre">rd</span></code> fields contain the IDs of the registers involved, hence they are 5 bit wide so that they can encode all 32 register IDs, hence they are represented by the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/uint.html" title="(in PyGears v0.1.1)"><code class="xref any docutils literal notranslate"><span class="pre">Uint[5]</span></code></a> type. ISA specifies that <code class="docutils literal notranslate"><span class="pre">addi</span></code> as a signed operation, and that the values in the <code class="docutils literal notranslate"><span class="pre">imm</span></code> field are encoded as signed integers, so I’ll use <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/int.html" title="(in PyGears v0.1.1)"><code class="xref any docutils literal notranslate"><span class="pre">Int[12]</span></code></a> type here.</p>
<p>Now any gear that operates on the <code class="docutils literal notranslate"><span class="pre">imm</span></code> field can, if needed, automatically adjust its operation to handle the signed numbers correctly, and I don’t have to worry about it for every gear excplicitely. This is a major advantage of the typing system, since I can express my intents using the type (like with <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/uint.html" title="(in PyGears v0.1.1)"><code class="xref any docutils literal notranslate"><span class="pre">Int</span></code></a> here) in a single place in the code, and this intent will propagate automatically throughout the design. Traditional HDLs offer only rudimentary typing support, so you need to follow you signals around and explictely. However, just specifying the type is only a half of the story. The other half lies in providing the Polymorphic behavior for the modules, so that they automatically accomadate for different data types.</p>
<p>OK, so now we have the <code class="docutils literal notranslate"><span class="pre">TInstructionI</span></code> type, that describes the general format for the “I-type” instructions, and my <code class="docutils literal notranslate"><span class="pre">addi</span></code> instruction will be an instance of this type. As I said, <code class="docutils literal notranslate"><span class="pre">opcode</span></code> and <code class="docutils literal notranslate"><span class="pre">funct3</span></code> will have unique, specific value for the <code class="docutils literal notranslate"><span class="pre">addi</span></code> instruction which is specified by ISA. I had to consult <a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf#page=115">Chapter 19: RV32/64G Instruction Set Listings</a> in order to get the correct values for the function ID fields: <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">opcode</span></span><span class="o"><span class="pre">=</span></span><span class="mh"><span class="pre">0x13</span></span></code> and <code class="docutils literal notranslate"><span class="pre">funct3=0x0</span></code>.</p>
<div class="figure align-center" id="id2">
<img alt="../_images/addi-instruction-field-value.png" src="../_images/addi-instruction-field-value.png" />
<p class="caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">addi</span></code> instruction format, from <a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">RISC-V ISA Specification</a></span></p>
</div>
<p>Other instruction fields: <code class="docutils literal notranslate"><span class="pre">rd</span></code>, <code class="docutils literal notranslate"><span class="pre">rs1</span></code> and <code class="docutils literal notranslate"><span class="pre">imm</span></code>, can take arbitrary values, so I can’t fix those in advance. This gives me the following template for the <code class="docutils literal notranslate"><span class="pre">addi</span></code> instruction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPCODE_IMM</span> <span class="o">=</span> <span class="mh">0x13</span>
<span class="n">FUNCT3_ADDI</span> <span class="o">=</span> <span class="mh">0x0</span>

<span class="n">ADDI</span> <span class="o">=</span> <span class="n">TInstructionI</span><span class="p">({</span>
    <span class="s1">&#39;opcode&#39;</span><span class="p">:</span> <span class="n">OPCODE_IMM</span><span class="p">,</span>
    <span class="s1">&#39;rd&#39;</span>    <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">&#39;funct3&#39;</span><span class="p">:</span> <span class="n">FUNCT3_ADDI</span><span class="p">,</span>
    <span class="s1">&#39;rs1&#39;</span>   <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="s1">&#39;imm&#39;</span>   <span class="p">:</span> <span class="mi">0</span>
<span class="p">})</span>
</pre></div>
</div>
<p>Since PyGears doesn’t have templates for type instances, all I can do is assign some default values to the fields whose values can change. Maybe its worth considering whether true generic templates (with generic parameters) for the type instances would add anything of value (or researching if there are languages that support these). In that case, instead of zeros above, the fields would be assigned some template placeholder names, that would need to be assigned values later. Prolog does something like that?</p>
</div>
<div class="section" id="processor-implementation">
<h2>Processor implementation<a class="headerlink" href="#processor-implementation" title="Permalink to this headline">¶</a></h2>
<p>Since the idea of this blog series is to show how one can evolve a complex hardware design using PyGears without wasted effort, by implementing one feature at a time, I will turn a blind eye to the fact that RISC-V processor needs to support multiple instructions at this moment. I will exclude the PC manipulation functionality, which gets important once jump instructions get into play, and the interface to the data memory, which gets important once load and store instructions git into play. For now I will move the <a class="reference external" href="https://github.com/bogdanvuk/pygears_riscv/blob/afb2/pygears_riscv/verif/register_file.py">register file</a> outside the processor into a separate module and implement it in pure Python to ease reading and writing for the verification purposes. Later, I’ll provide an RTL implementation of the register file, but it is a simple module and it should be a straightforward design process, so I don’t feel like cheating for postponing it. Important concepts for describing gears are sketched-out in this <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/introduction.html#introduction" title="(in PyGears v0.1.1)"><span class="xref std std-ref">Quick Introduction</span></a> documentation page. Without further ado, this single-instruction capable RISC-V processor written in PyGears looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@gear</span>
<span class="k">def</span> <span class="nf">riscv</span><span class="p">(</span><span class="n">instruction</span><span class="p">:</span> <span class="n">TInstructionI</span><span class="p">,</span> <span class="n">reg_data</span><span class="p">:</span> <span class="n">Uint</span><span class="p">[</span><span class="s1">&#39;xlen&#39;</span><span class="p">]):</span>

    <span class="n">reg_file_rd_req</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">[</span><span class="s1">&#39;rs1&#39;</span><span class="p">]</span>

    <span class="n">add_res</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg_data</span> <span class="o">|</span> <span class="n">Int</span><span class="p">)</span> <span class="o">+</span> <span class="n">instruction</span><span class="p">[</span><span class="s1">&#39;imm&#39;</span><span class="p">])</span> <span class="o">|</span> <span class="n">reg_data</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">reg_file_wr_req</span> <span class="o">=</span> <span class="n">ccat</span><span class="p">(</span><span class="n">instruction</span><span class="p">[</span><span class="s1">&#39;rd&#39;</span><span class="p">],</span> <span class="n">add_res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reg_file_rd_req</span><span class="p">,</span> <span class="n">reg_file_wr_req</span>
</pre></div>
</div>
<p>Let’s dig deeper into those 6 lines of code. The <code class="code highlight py docutils literal notranslate"><span class="nd"><span class="pre">&#64;gear</span></span></code> statement is called a decorator in Python terminology. If it is placed in front of the function definition it can wrap it with some additional code. The <code class="code highlight py docutils literal notranslate"><span class="nd"><span class="pre">&#64;gear</span></span></code> decorator is where most of the magic happens in PyGears. It makes a function composable via  ‘|’ (pipe) operator, it performs type checking and matching, it instantiates a new hardware module each time the function is called, it takes care about module hierarchy, etc.</p>
<p>Next, the <a class="reference external" href="https://en.wikipedia.org/wiki/Function_prototype">function prototype</a>  declares the types of input interfaces the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear accepts, namely: <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">instruction</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">TInstructionI</span></span></code> and <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">reg_data</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Uint</span></span><span class="p"><span class="pre">[</span></span><span class="s1"><span class="pre">‘xlen’</span></span><span class="p"><span class="pre">]</span></span></code>. So on the first interface <code class="docutils literal notranslate"><span class="pre">riscv</span></code> expects to see a flow of instructions of the “I-type” format, and on the second, the operation argument read from the register determined by the <code class="docutils literal notranslate"><span class="pre">rs1</span></code> field (<code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear will issue this read request as we’ll see in the moment). For the details on how PyGears implements interfaces in HDL, checkout the PyGears documentation section <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/gears.html#gears-interface" title="(in PyGears v0.1.1)"><span class="xref std std-ref">One Interface</span></a>. The <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear is implemented via gear composition, so I needn’t specify the output interfaces since they will be determined by which interfaces are returned by the function.</p>
<p>In order to instantiate the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear, all the input interfaces need to be specified as arguments to the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear function. Inside the <code class="docutils literal notranslate"><span class="pre">gear</span></code> function, <code class="docutils literal notranslate"><span class="pre">instruction</span></code> and <code class="docutils literal notranslate"><span class="pre">reg_data</span></code> become local variables that bring the interface objects from the outside and distribute them to the internal gears. Image below shows the resulting processor structure and connection with its environment. The graph was autogenerated with the <a class="reference external" href="https://github.com/bogdanvuk/pygears_riscv/blob/afb2/pygears_riscv/script/riscv_graph.py">riscv_graph.py script</a>.</p>
<div class="figure align-center" id="id3">
<img alt="../_images/riscv_graph_addi.png" src="../_images/riscv_graph_addi.png" />
<p class="caption"><span class="caption-text">Graph of the single-instruction RISC-V processor implementation in PyGears. The gears are drown as octagons and hierarchical modules are drawn as boxes.</span></p>
</div>
<p>First line of the function: <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">reg_file_rd_req</span></span> <span class="o"><span class="pre">=</span></span> <span class="n"><span class="pre">instruction</span></span><span class="p"><span class="pre">[</span></span><span class="s1"><span class="pre">‘rs1’</span></span><span class="p"><span class="pre">]</span></span></code>, forms a read request for the register file and results in the <code class="docutils literal notranslate"><span class="pre">instruction_rs1</span></code> gear shown in the graph above. The request consists only of the register ID from which to read the data, which is given in the <code class="docutils literal notranslate"><span class="pre">rs1</span></code> instruction field. Simply by slicing the <code class="docutils literal notranslate"><span class="pre">instruction</span></code> interface with the field name, I can tell PyGears to extract the desired part of the incoming data. For more information about slicing the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/tuple.html" title="(in PyGears v0.1.1)"><code class="docutils literal notranslate"><span class="pre">Tuple</span></code></a> type, checkout <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/tuple.html#pygears.typing.tuple.TupleType.__getitem__" title="(in PyGears v0.1.1)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Tuple.__getitem__()</span></code></a>. This a zero-overhead abstraction and results in nothing but wiring in generated SystemVerilog. After Python executes this statement, the variable <code class="docutils literal notranslate"><span class="pre">reg_file_rd_req</span></code> containes the output interface of the <code class="docutils literal notranslate"><span class="pre">instruction_rs1</span></code> gear (this is a <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/gears/common.html#pygears.common.sieve" title="(in PyGears v0.1.1)"><code class="xref any docutils literal notranslate"><span class="pre">sieve</span></code></a> gear, automatically generated whenever interfaces are sliced), which is later lead out of the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear by returning the variable value: <code class="code highlight py docutils literal notranslate"><span class="k"><span class="pre">return</span></span> <span class="n"><span class="pre">reg_file_rd_req</span></span><span class="p"><span class="pre">,</span></span> <span class="n"><span class="pre">reg_file_wr_req</span></span></code>.</p>
<p>Next, the signed addition is performed. First, the data read from the register <code class="docutils literal notranslate"><span class="pre">rs1</span></code> is cast to be interpreted as a signed value: <code class="docutils literal notranslate"><span class="pre">(reg_data</span> <span class="pre">|</span> <span class="pre">Int)</span></code>, which results in the <code class="docutils literal notranslate"><span class="pre">cast_reg_data</span></code> gear shown in the graph. Then, the addition is performed with the <code class="docutils literal notranslate"><span class="pre">imm</span></code> instruction field, resulting in the <code class="docutils literal notranslate"><span class="pre">add</span></code> gear in the graph. Finally, the addition result is cast back to the type of the <code class="docutils literal notranslate"><span class="pre">reg_data</span></code> interface: <code class="docutils literal notranslate"><span class="pre">reg_data.dtype</span></code>, which truncates the result by 1 bit and changes it type back to unsigned integer. The interface carrying the result of these operations is stored in the variable <code class="docutils literal notranslate"><span class="pre">add_res</span></code>.</p>
<p>Next, the write request <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">reg_file_wr_req</span></span> <span class="o"><span class="pre">=</span></span> <span class="n"><span class="pre">ccat</span></span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">instruction</span></span><span class="p"><span class="pre">[</span></span><span class="s1"><span class="pre">‘rd’</span></span><span class="p"><span class="pre">],</span></span> <span class="n"><span class="pre">add_res</span></span><span class="p"><span class="pre">)</span></span></code> is formed, with which the register file is instructed to store the result of the addition (variable <code class="docutils literal notranslate"><span class="pre">add_res</span></code>) into the register specified by the <code class="docutils literal notranslate"><span class="pre">rd</span></code> instruction field. These two pieces of information are combined in a <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/typing/tuple.html" title="(in PyGears v0.1.1)"><code class="docutils literal notranslate"><span class="pre">Tuple</span></code></a> by using <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/gears/common.html#pygears.common.ccat" title="(in PyGears v0.1.1)"><code class="xref any docutils literal notranslate"><span class="pre">ccat</span></code></a> (short for concat) gear from the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/gears/common.html" title="(in PyGears v0.1.1)"><code class="xref any docutils literal notranslate"><span class="pre">pygears.common</span></code></a> library.</p>
<p>The read and write requests are output from the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear by outputting them from the function, and will be connected to the inputs of the register file module in a higher hierarchy level.</p>
</div>
<div class="section" id="verification-environment">
<h2>Verification environment<a class="headerlink" href="#verification-environment" title="Permalink to this headline">¶</a></h2>
<p>For testing the ISA implementation, I’ve envisioned the following test:</p>
<ol class="arabic simple">
<li><p>Initialize the register file</p></li>
<li><p>Send a stream of instructions to the processor</p></li>
<li><p>Check the final register values to the reference design</p></li>
</ol>
<p>I’ve vriten an environment that supports these kinds of tests in <a class="reference external" href="https://github.com/bogdanvuk/pygears_riscv/blob/afb2/pygears_riscv/verif/env.py">verif/env.py</a>. This is a regular Python function (not a gear) that instantiates the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> and <code class="docutils literal notranslate"><span class="pre">register_file</span></code> gears and wires them properly in the following manner:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/addi-env-block-diagram.png"><img alt="../_images/addi-env-block-diagram.png" src="../_images/addi-env-block-diagram.png" style="width: 80%;" /></a>
</div>
<p>Relevant part of the <a class="reference internal" href="#riscv_instr_seq_env" title="riscv_instr_seq_env"><code class="xref py py-func docutils literal notranslate"><span class="pre">riscv_instr_seq_env()</span></code></a> function is given below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">riscv_instr_seq_env</span><span class="p">(</span><span class="n">instr_seq</span><span class="p">,</span> <span class="n">xlen</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">reg_file_mem</span><span class="o">=</span><span class="p">{}):</span>

    <span class="n">instruction</span> <span class="o">=</span> <span class="n">drv</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">TInstructionI</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="n">instr_seq</span><span class="p">)</span>

    <span class="n">reg_rd_data</span> <span class="o">=</span> <span class="n">Intf</span><span class="p">(</span><span class="n">Uint</span><span class="p">[</span><span class="n">xlen</span><span class="p">])</span>

    <span class="n">reg_file_rd_req</span><span class="p">,</span> <span class="n">reg_file_wr_req</span> <span class="o">=</span> <span class="n">riscv</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">reg_rd_data</span><span class="p">)</span>

    <span class="n">reg_rd_data</span> <span class="o">|=</span> \
        <span class="n">register_file</span><span class="p">(</span><span class="n">reg_file_rd_req</span><span class="p">,</span> <span class="n">reg_file_wr_req</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="n">reg_file_mem</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reg_file_mem</span>
</pre></div>
</div>
<p>Here you can see the signature of the function and description of its arguments:</p>
<dl class="function">
<dt id="riscv_instr_seq_env">
<code class="descname">riscv_instr_seq_env</code><span class="sig-paren">(</span><em>instr_seq</em>, <em>xlen=32</em>, <em>reg_file_mem={}</em><span class="sig-paren">)</span><a class="headerlink" href="#riscv_instr_seq_env" title="Permalink to this definition">¶</a></dt>
<dd><p>Drives riscv with an instruction sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>instr_seq</strong> – Sequence of instructions to send to riscv</p></li>
<li><p><strong>xlen</strong> – Width of the riscv registers in bits</p></li>
<li><p><strong>reg_file_mem</strong> – Initial register file dictionary that maps register IDs to their initial values</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>reg_file_mem</p>
</dd>
</dl>
</dd></dl>

<p>The <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/gears/simulation_gears.html#pygears.sim.modules.drv" title="(in PyGears v0.1.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">drv</span></code></a> gear can be used to drive a sequence of values to an input interface of a gear. In this case it will drive the sequence of instructions, passed via <code class="docutils literal notranslate"><span class="pre">instr_seq</span></code> argument: <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">instruction</span></span> <span class="o"><span class="pre">=</span></span> <span class="n"><span class="pre">drv</span></span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="n"><span class="pre">TInstructionI</span></span><span class="p"><span class="pre">,</span></span> <span class="n"><span class="pre">seq</span></span><span class="o"><span class="pre">=</span></span><span class="n"><span class="pre">instr_seq</span></span><span class="p"><span class="pre">)</span></span></code>. As you can see, the <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">seq</span></code> arguments to the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/gears/simulation_gears.html#pygears.sim.modules.drv" title="(in PyGears v0.1.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">drv</span></code></a> gear need to be specified using keywords. The reason is that the current implementation of the PyGears needs to distinguish between gear input interfaces and gear parameters, so only input interfaces are allowed to be passed as positional argments(without argument names).</p>
<p>Next, I hook up the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> and <code class="docutils literal notranslate"><span class="pre">register_file</span></code> gears in the manner shown on the block diagram. You can see from the diagram that these two gears form a kind of a loop, so their connection cannot be expressed in a forward only manner. In these cases, we need to break the loop somewhere, connect the gears in a forward manner and then reconnect the loop at the point where it was broken. I decided to brake the loop at the <code class="docutils literal notranslate"><span class="pre">reg_rd_data</span></code> interface (as shown on the block diagram), so I explicitly instantiated the interface object with the desired type for the <code class="docutils literal notranslate"><span class="pre">reg_rd_data</span></code> interface: <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">reg_rd_data</span></span> <span class="o"><span class="pre">=</span></span> <span class="n"><span class="pre">Intf</span></span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">Uint</span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">xlen</span></span><span class="p"><span class="pre">])</span></span></code>. This way we can feed it to the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear, together with the <code class="docutils literal notranslate"><span class="pre">instruction</span></code> interface, and the <code class="docutils literal notranslate"><span class="pre">riscv</span></code> gear will have all the information needed to resolve itself and produce the output interfaces: <code class="code highlight py docutils literal notranslate"><span class="n"><span class="pre">reg_file_rd_req</span></span><span class="p"><span class="pre">,</span></span> <span class="n"><span class="pre">reg_file_wr_req</span></span> <span class="o"><span class="pre">=</span></span> <span class="n"><span class="pre">riscv</span></span><span class="p"><span class="pre">(</span></span><span class="n"><span class="pre">instruction</span></span><span class="p"><span class="pre">,</span></span> <span class="n"><span class="pre">reg_rd_data</span></span><span class="p"><span class="pre">)</span></span></code></p>
<p>Finally, I connect <code class="docutils literal notranslate"><span class="pre">riscv</span></code> read and write request interfaces to the <code class="docutils literal notranslate"><span class="pre">register_file</span></code> gear, which gets instantiated and returns its output interface. Instead of it being fed to another gear or assigned to a variable, I use the pipe assign operator <code class="docutils literal notranslate"><span class="pre">|=</span></code> to instruct PyGears that this output interface is in fact the <code class="docutils literal notranslate"><span class="pre">reg_rd_data</span></code> interface I defined before. This closes the loop and everything is connected as shown on the block diagram.</p>
<div class="section" id="spike-interface">
<h3>Spike interface<a class="headerlink" href="#spike-interface" title="Permalink to this headline">¶</a></h3>
<p>In my previous blog post <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/setup.html" title="(in PyGears v0.1.1)"><span>PyGears Tools Setup for Linux</span></a>, I showed how to implement a rudimentary interface for the <a class="reference external" href="https://github.com/riscv/riscv-isa-sim/">Spike</a> simulator that I plan to use as a reference ISA design. Now, I’ll show how to put it to action for verifying the <code class="docutils literal notranslate"><span class="pre">addi</span></code> instruction implementation. I relocated the Spike interface class to <a class="reference external" href="https://github.com/bogdanvuk/pygears_riscv/blob/afb2/pygears_riscv/verif/spike.py">verif/spike.py</a> and had to make one major change to accomodate for the RISC-V <a class="reference external" href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI (Application Binary Interface)</a>.</p>
<p>First, I was surprised to find that issuing the read register command didn’t return any value in Spike simulator if the registers were named with prefix “x” (<code class="docutils literal notranslate"><span class="pre">x*</span></code>). I started digging and found out that even though all registers <code class="docutils literal notranslate"><span class="pre">x1</span></code> - <code class="docutils literal notranslate"><span class="pre">x31</span></code> were created equal in the ISA specification, in order to cooperate better with C compilers additional rules were created, namely the ABI. <a class="reference external" href="https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf#page=121">Chapter 20: RISC-V Assembly Programmer’s Handbook</a> provides the table that maps the native <code class="docutils literal notranslate"><span class="pre">x*</span></code> register names to their ABI equivalents, and specifies special purpose for each of the registers. It turns out that the Spike simulator understands only the ABI register names. Some additional information on the ABI, together with the examples of the assembly instruction syntax, is also given on <a class="reference external" href="https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md">riscv/riscv-elf-psabi-doc github</a>.</p>
<p>I created a wrapper class around my Spike interface inside <a class="reference external" href="https://github.com/bogdanvuk/pygears_riscv/blob/afb2/pygears_riscv/verif/spike_instr_test.py">verif/spike_instr_test.py</a>, which automates all the tasks I did manually in the <a class="reference external" href="/tools/home/pygears/docs/manual/_build/html/setup.html" title="(in PyGears v0.1.1)"><span class="xref std std-doc">previous blog post</span></a>, namely: writting the assembly file, running the gcc, and calling Spike interface with the correct parameters. I also added the possibility to easily initialize the register values which will come in handy for thourough verification.</p>
<div class="highlight-jinja notranslate"><div class="highlight"><pre><span></span><span class="x">;; # Assembly program template.</span>

<span class="x">.text</span>
<span class="x">  .global _start</span>

<span class="x">_start:</span>
<span class="cp">{%</span> <span class="k">for</span> <span class="nv">reg</span><span class="o">,</span> <span class="nv">value</span> <span class="k">in</span> <span class="nv">reg_set_init.items</span><span class="o">()</span> <span class="cp">%}</span><span class="x"></span>
<span class="x">.equ X</span><span class="cp">{{</span> <span class="nv">reg</span> <span class="cp">}}</span><span class="x">_INIT_VALUE, </span><span class="cp">{{</span> <span class="nv">value</span> <span class="cp">}}</span><span class="x"></span>
<span class="cp">{%</span>- <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>

<span class="x">  ;; # Optional preloading of initial register values.</span>
<span class="cp">{%</span> <span class="k">for</span> <span class="nv">reg</span> <span class="k">in</span> <span class="nv">reg_set_init</span> <span class="cp">%}</span><span class="x"></span>
<span class="x">  lui x</span><span class="cp">{{</span> <span class="nv">reg</span> <span class="cp">}}</span><span class="x">,      %hi(X</span><span class="cp">{{</span> <span class="nv">reg</span> <span class="cp">}}</span><span class="x">_INIT_VALUE)</span>
<span class="x">  addi x</span><span class="cp">{{</span> <span class="nv">reg</span> <span class="cp">}}</span><span class="x">, x</span><span class="cp">{{</span> <span class="nv">reg</span> <span class="cp">}}</span><span class="x">, %lo(X</span><span class="cp">{{</span> <span class="nv">reg</span> <span class="cp">}}</span><span class="x">_INIT_VALUE)</span>
<span class="cp">{%</span>- <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>

<span class="x">  ;; # The actual instructions I&#39;d like to test.</span>
<span class="cp">{%</span> <span class="k">for</span> <span class="nv">instruction</span> <span class="k">in</span> <span class="nv">instructions</span> <span class="cp">%}</span><span class="x"></span>
<span class="x">  </span><span class="cp">{{</span> <span class="nv">disassemble</span><span class="o">(</span><span class="nv">instruction</span><span class="o">)</span> <span class="cp">}}</span><span class="x"></span>
<span class="cp">{%</span>- <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>

<span class="x">  ;; # Write the value 1 to tohost, telling Spike to quit with 0 exit code.</span>
<span class="x">  li t0, 1</span>
<span class="x">  la t1, tohost</span>
<span class="x">  sw t0, 0(t1)</span>

<span class="x">  ;; # Spin until Spike terminates the simulation.</span>
<span class="x">  1: j 1b</span>

<span class="x">;; # Expose tohost and fromhost to Spike so we can communicate with it.</span>
<span class="x">.data</span>
<span class="x">  .global tohost</span>
<span class="x">tohost:   .dword 0</span>
<span class="x">  .global fromhost</span>
<span class="x">fromhost: .dword 0&quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="figure align-center" id="id4">
<img alt="../_images/addi-timelapse.gif" src="../_images/addi-timelapse.gif" />
<p class="caption"><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">addi</span></code> instruction simulation timelapse. Each frame is a single delta cycle.</span></p>
</div>
<dl class="simple">
<dt>Tried <code class="docutils literal notranslate"><span class="pre">li</span></code> approach, but failed with::</dt>
<dd><dl class="simple">
<dt>terminate called after throwing an instance of ‘std::runtime_error’</dt>
<dd><p>what():  misaligned address</p>
</dd>
</dl>
</dd>
</dl>
<p><a class="reference external" href="https://github.com/riscv/riscv-asm-manual/blob/master/riscv-asm.md">this guide</a>, finally succeeded with “Constant”.</p>
</div>
</div>
</div>

  <div class="section">
  
    


  
  
  </div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
    <a href="https://www.pygears.org">
        <img class="logo" src="../_static/logo.png" alt="Logo"/>
        
    </a>
</p>



<p class="blurb">HW Design: A Functional Approach</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=bogdanvuk&repo=pygears&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






  
  
  <h2>
  
    
     Draft 
  
  </h2>

  <ul>
    

  
  <li id="author"><span>Author:</span>
    
      
      <a href="../blog/author/bogdan-vukobratovic.html">Bogdan Vukobratović</a>
      
    </li>
  

  

  

  
  <li id="category"><span>Category:</span>
    
      
      <a href="../blog/category/risc-v.html">RISC-V</a>
      
    </li>
  

  
  
  </ul>



  <h3><a href="../blog.html">Recent Posts</a></h3>
  <ul>
    
    
      <li><a href="setup.html">07 October - RISC-V Tools Setup</a></li>
    
      <li><a href="../release/v0.1.1.html">07 October - PyGears 0.1.1 released</a></li>
    
      <li><a href="introduction.html">06 October - RISC-V Blog Series Introduction</a></li>
    
  </ul>

  <h3><a href="../blog/tag.html">Tags</a></h3>
  <style type="text/css">
    ul.ablog-cloud {list-style: none; overflow: auto;}
    ul.ablog-cloud li {float: left; height: 20pt; line-height: 18pt; margin-right: 5px;}
    ul.ablog-cloud a {text-decoration: none; vertical-align: middle;}
    li.ablog-cloud-1{font-size: 80%;}
    li.ablog-cloud-2{font-size: 95%;}
    li.ablog-cloud-3{font-size: 110%;}
    li.ablog-cloud-4{font-size: 125%;}
    li.ablog-cloud-5{font-size: 140%;}
  </style>
  <ul class="ablog-cloud">
    
      
      <li class="ablog-cloud ablog-cloud-3">
        <a href="../blog/tag/setup.html">setup</a></li>
      
    
  </ul>

  <h3><a href="../blog/category.html">Categories</a></h3>
  <ul>
  
    
    <li><a href="../blog/category/risc-v.html">RISC-V (2)</a></li>
    
  
    
    <li><a href="../blog/category/release.html">Release (1)</a></li>
    
  
  </ul>

  <h3><a href="../blog/archive.html">Archives</a></h3>
  <ul>
  
    
    <li><a href="../blog/2018.html">2018 (3)</a></li>
    
  
  </ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Bogdan Vukobratovic.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
      |
      <a href="../_sources/riscv/my_first_instruction.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>