Introduction
============

RTL methodology is still a primary method for describing digital hardware systems, usually using some variation of the FSMD (Finite State Machine with Datapath) model :cite:`chu2006rtl`. For an example, in :cite:`chu2006rtl` a method for translating sequential algorithms into a FSMD model is given., however no guidlines are given on how to efficiently refactor the design into easily composable subparts. Control flow (FSM) is a main impediment to composition since it imposes no restrictions on how the state is manipulated (hidden state), hence corresponding to an impure function. This is a major problem when two such modules need to be composed in a predictible manner. Number of possible walks of the state through time rises rapidly with the number of allowed transitions and the length of number of transitions. FSMD focuses on footprint optimization, however time-to-market today more important (new revisions). FPGA-s -> continuous maintenance.

There are many attemts at providing an alternative to the RTL :cite:`nane2016survey`. They usually focus on a specific design domain like streaming designs :cite:`serot2013caph, gupta2003spark`. Bluespec :cite:`nikhil2004bluespec` supports a general concurrent computation model, based on guarded atomic actions. While these can provide great designer productivity when the task in hand matches the pattern encoded in the application programming model, they are a poor match for tasks outside their domain. For example, the design of a programmable microprocessor is not well described in a stream programming model, and guarded atomic actions are not a natural way to express a high-level DSP algorithm. Bluespec Compiler (BSC) [14] is a tool that uses Bluespec System Verilog (BSV) as the design language. BSV is a high-level functional HDL based on Verilog and inspired by Haskell, where modules are implemented as a set of rules using Verilog syntax. The rules are called Guarded Atomic Actions and express behaviour in the form of concurrently cooperating FSMs [15]. Using this language, and implicitly the BSC tool, requires developers with specific expertise.

Next, there are numerous methods that propose describing hardware in a procedural language like C and then offer automated tools to synthesize the procedural description into a standard HDL :cite:`VivadoHLS,villarreal2010designing,gupta2003spark`. These have only had a limited success and are targeted also for streaming applications.

In this paper, a novel methodology called Gears is presented that aims to complement this approach by imposing additional constraints on the resulting hardware module. Authors have recognized that the lack of the composability of the modules generated by the traditional methodologies is adds dramatically to the complexity of the hardware design. Gears methodology tries to alleviate this by advocating the heavy use of pure hardware modules that are analogous to the pure functions [citation?]. Pure modules are more predictable. Non-trivial pure modules of course need to have an internal state, but they are required to have defined initial state, to which they must return after the output is computed from the provided inputs. Also single-responsibility principle. In FSMD, single FSM is responsible for overlooking a complex algorithmic procedure -> huge and complicated FSM -> hard to compose, hard to test.

Regarding hardware-description languages, Verilog and VHDL are still by far the most commonly used. These languages were originally developed as hardware simulation languages, and were only later adopted as a basis for hardware synthesis. Because the semantics of these languages are based around simulation, synthesizable designs must be inferred from a subset of the language, complicating tool development and designer education. These languages also lack the powerful abstraction facilities that are common in modern software languages, which leads to low designer productivity by making it difficult to reuse components. SystemVerilog mainly improved the verification capabilities of the Verilog language. Regarding the synthesis language subset, besides few shortcut notations, no major tools and facilities were added.

In an attempt to provide an alternative to the traditional hardware-description languages, many different programming languages have been repurposed for the task of the hardware design, like: Scala :cite:`bachrach2012chisel,SpinalHDL`, Haskell :cite:`baaij2010c`, Python :cite:`decaluwe2004myhdl`, etc. While these languages offer higher level constructs that do facilitate certain aspects of describing the hardware, they still rely on the traditional RTL methodology, and as such do not raise an abstraction level at which the hardware is designed.

Although the Gears methodology can be excercised with any hardware-description language, we developped PyGears, a Python framework for hardware design. Many libraries avalilable for Python can be used for simulation.
