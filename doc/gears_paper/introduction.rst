Introduction
============

RTL methodology is still a primary method for describing digital hardware systems, usually via some variation of the FSMD (Finite State Machine with Datapath) model :cite:`chu2006rtl`. FSMD intermediate model provides a way of translating sequential algorithms into a hardware description consisting of a dataflow which implements data transformations and a control flow (described using a FSM) which controls under which circumstances the transformations are applied. However, for real world examples obtained control flow FSM can be quite complex, and RTL methodology offers very few guidlines on how to efficiently refactor the design into smaller manageable units. Manipulating a complex FSM (like debugging, adding a new feature, pipelining, etc.), can offer a significant challenge. Furthermore, complex modules are hard to reuse and thoroughly test. 

There are many attemts at providing an alternative to the RTL :cite:`nane2016survey`. They usually focus on a specific design domain like streaming systems for example :cite:`serot2013caph,gupta2003spark`. Similarly, Bluespec :cite:`nikhil2004bluespec` uses so called Guarded Atomic Actions to describe the design in form of concurent FSMs. These tools can be valuable when the task at hand matches the domain they support, but they offer no benefits outside of it. *For example, the design of a programmable microprocessor is not well described in a stream programming model, and guarded atomic actions are not a natural way to express a high-level DSP algorithm*.

Next, there are numerous methods that propose describing hardware in a procedural languages like C, and then offer automated tools to synthesize the procedural description into a standard HDL :cite:`VivadoHLS,villarreal2010designing,gupta2003spark`. These have only had a limited success and are also usually targeted for a specific domain, like streaming applications.

In this paper, we introduce Gears, a novel hardware design methodology that aims to complement the traditional approach by imposing additional constraints on the hardware modules being designed. Authors have recognized that the lack of the composability of the modules generated by the traditional methodologies significantly increases the complexity of the hardware design in general. Gears requires the use of a simple handshake interface called DTI (Data Tranfer Interface) for all communication between modules, which allows for them to be viewed as mathematical objects from Category theory :cite:`awodey2010category`, which in turn provides a rich set of tools for composing such modules. Ease of module compositions allows for factoring the design into smaller units, which are easier to write, test and reuse, which in turn enables forming comprehensible, well-tested libraries. This finally leads to significantly reduced efforts when designing hardware with such libraries.   

Regarding hardware-description languages, Verilog and VHDL are still by far the most commonly used. These languages were originally developed as hardware simulation languages, and were only later adopted as a basis for hardware synthesis. Because the semantics of these languages are based around simulation, synthesizable designs must be inferred from a subset of the language, complicating tool development and designer education. These languages also lack the powerful abstraction facilities that are common in modern software languages, which leads to low designer productivity by making it difficult to reuse components. SystemVerilog mainly improved the verification capabilities of the Verilog language, however regarding the synthesis language subset, besides few shortcut notations, no major tools and facilities were added.

In an attempt to provide an alternative to the traditional hardware-description languages, many different programming languages have been repurposed for the task of the hardware design, like: Scala :cite:`bachrach2012chisel,SpinalHDL`, Haskell :cite:`baaij2010c`, Python :cite:`decaluwe2004myhdl`, etc. While these languages offer higher level constructs that do facilitate certain aspects of describing the hardware, they still rely on the traditional RTL methodology, and as such do not raise the abstraction level at which the hardware is designed.

Although the Gears methodology can be excercised with any hardware-description language, we developped PyGears, a Python framework for hardware description that is specifically designed to express composition of the modules adhering to the Gears methodology in a most elegant and natural way.
